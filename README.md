In our School Management System, the keyword and is used to check if a student is both present and has submitted assignments (attendance and assignments_submitted). The keyword or helps determine if a student qualifies based on at least one condition being met (attendance or assignments_submitted). Meanwhile, not is used to negate a condition, such as when checking if assignments are missing (not assignments_submitted).
The keyword if is used to decide whether a student passes or fails (if grade >= 90). If the first condition is false, the program checks another condition using elif, such as when a student has a B grade (elif grade >= 75). If none of the conditions are met, else provides a default action, like failing the student (else: print("Grade: F")).
To track attendance, we loop through student names using for (for student in students). If we want to skip a specific student, continue is used (if student == "Bob": continue). If we need to stop the loop, break ensures we exit early (if student == "Charlie": break). A while loop keeps running as long as a condition is met (while attendance is True). The pass keyword acts as a placeholder when a condition is required but no action is needed (if grade >= 60: pass).
The keyword def is used to define a function for calculating grades (def calculate_grade(score)). To return a result from the function, we use return (return "Pass"). If we need to modify a variable that exists outside a function, we declare it as global (global passing_grade). Inside nested functions, nonlocal allows modifying a variable from an outer function (nonlocal status).
We use try to attempt risky operations like retrieving student scores (try: student_scores["Bob"]). If an error occurs, except handles it (except KeyError as e). The keyword as assigns the error to a variable (except KeyError as e:). Regardless of the outcome, finally ensures that the program prints a message (finally: print("Finished processing")). We use assert to verify conditions (assert student_scores["Bob"] is not None). If a serious issue arises, raise forces an error (raise ValueError("Missing Score")).
To organize student data, we create a class using class (class Student:). Inside a class, self refers to the instance of the student object (self.name = name).
To store student records safely, we open a file using with (with open("students.txt", "w") as file). This ensures the file is automatically closed after writing data.
If a student drops out, their data is deleted using del (del student1). When a value does not exist, it is set to None (student_score = None). We use is to check if a variable is truly None (if student_score is None).
The import keyword brings in external functionality (import math). If we need a specific feature from a module, we use from (from datetime import datetime).
For quick calculations, lambda creates anonymous functions (square = lambda x: x * x). The yield keyword generates values one by one (yield f"Follow up with: {student}").
